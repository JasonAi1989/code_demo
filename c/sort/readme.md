这一部分主要是各种排序算法的一个demo

冒泡排序：一次比较两个数，如果符合交换规则就进行数据交换，否则不变，然后循环遍历，直到所有的数据都按某一规则排列。
        时间复杂度为：O(n^2)
		
插入排序：将前k(1<=k<n)个元素排好顺序，然后将第k+1个元素插入到前面排好序的队列中
		时间复杂度为：O(n^2)
		
选择排序：将第k个元素和前k-1个元素中比k大的元素进行交换
		时间复杂度为：O(n^2)
		
以上3中排序方案时间复杂度一样，并且都是原地排序算法（在排序输入数组时，只有常数个元素被存储在数组以外的空间中）

归并排序（分治法）：以类似二分查找的方式，将对整个数组的排序变成先对小数组的排序，然后再将小数组合并，递归执行，直到将所有元素排序
		时间复杂度为：O(nlgn)  可理解为分为了lgn层（二叉树方法），然后每层合并时的时间复杂度为n，结果便是nlgn
		
归并排序时间复杂度上比插入排序等算法快，但是归并排序是非原地排序算法，所以空间复杂度上会较大

堆排序（堆数据结构）：以堆这种数据结构为依托进行的一种排序方案。堆是一种完全二叉树，有最大堆和最小堆之分，在堆排序中使用的是最大堆，在优先级队列中偏向使用最小堆。最大堆的父节点的值比子节点的值大，根节点的值最大；最小堆的父节点的值比子节点的值小，根节点的值最小。堆的最大优点是可以快速（lgn）的在树中比对值得大小，将树中的最大值或者最小值交换到根节点上。
		时间复杂度为：O(nlgn)
与归并排序不同，堆排序是原地排序算法，不需要非常大的空间复杂度

快速排序（分治法）：快速排序和归并排序一样，使用了分治法。但归并排序是从数组的中间位置进行划分，因此整体算法复杂度是稳定的nlgn，但是快速排序采用的并非在中间位置进行划分，它的划分函数PARTITION返回了一个位置，这个位置之前的子数组的所有值（并不是按顺序排列的值）都比此位置的值小（小于等于），而此位置的值也比这个位置之后的子数组的所有值（同样也并非是按顺序排列的值）小（小于等于），这个位置之前或者之后的子数组都可能是个空数组。PARTITION函数兼具了排序和返回位置的功能，但它进行的排序是将数组a，值，数组b进行了排序。如果每次找到的位置q正好是数组的中间位置，则算法的时间复杂度为nlgn，如果每次找到的位置q正好是数组的倒数第二个元素，则算法的时间复杂度为n^2。因此，讨论此算法时会关注它的最坏情况和最佳情况，不过整体上的平均复杂度是趋于nlgn的。会导致算法出现最坏情况的事件可能会是数组中所有元素都相等（相等的元素越多，情况越糟糕），或者数组中所有元素正好是倒序排列。
平均时间复杂度是nlgn，并且是原地排序算法。
堆排序是渐进最优的比较排序算法，达到了O(nlgn)这一下界，而快排有一定的可能性会产生最坏划分，时间复杂度可能为O(n^2)，那为什么快排在实际使用中通常优于堆排序？
回顾一下堆排的过程：

1. 建立最大堆（堆顶的元素大于其两个儿子，两个儿子又分别大于它们各自下属的两个儿子... 以此类推）

2.将堆顶的元素和最后一个元素对调（相当于将堆顶元素（最大值）拿走，然后将堆底的那个元素补上它的空缺），然后让那最后一个元素从顶上往下滑到恰当的位置（重新使堆最大化）。

3. 重复第2步。

这里的关键问题就在于第2步，堆底的元素肯定很小，将它拿到堆顶和原本属于最大元素的两个子节点比较，它比它们大的可能性是微乎其微的。实际上它肯定小于其中的一个儿子。而大于另一个儿子的可能性非常小。于是，这一次比较的结果就是概率不均等的，根据前面的分析，概率不均等的比较是不明智的，因为它并不能保证在糟糕情况下也能将问题的可能性削减到原本的1/2。可以想像一种极端情况，如果a肯定小于b，那么比较a和b就会什么信息也得不到――原本剩下多少可能性还是剩下多少可能性。

在堆排里面有大量这种近乎无效的比较，因为被拿到堆顶的那个元素几乎肯定是很小的，而靠近堆顶的元素又几乎肯定是很大的，将一个很小的数和一个很大的数比较，结果几乎肯定是“小于”的，这就意味着问题的可能性只被排除掉了很小一部分。

这就是为什么堆排比较慢（堆排虽然和快排一样复杂度都是O(NlogN)但堆排复杂度的常系数更大）。

MacKay也提供了一个修改版的堆排：每次不是将堆底的元素拿到上面去，而是直接比较堆顶（最大）元素的两个儿子，即选出次大的元素。由于这两个儿子之间的大小关系是很不确定的，两者都很大，说不好哪个更大哪个更小，所以这次比较的两个结果就是概率均等的了

计数排序：其基本思想就是对每一个输入元素x，确定出小于x的元素个数。有了这一信息，就可以把x直接放到它在最终输出数组中的位置上。例如，如果有17个元素小于x，则x就属于第18个输出位置。当有几个元素相同时，这个方案要略做修改，因为不能把他们放在同一输出位置上。
计数排序的时间复杂度为O(n)，但它为非原地排序

基数排序：
